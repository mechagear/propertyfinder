<?php
/**
 * Created by PhpStorm.
 * User: maxru
 * Date: 01.08.17
 * Time: 23:20
 */

namespace Mechagear\PF\Models\Collections;


use Mechagear\PF\Models\Cards\CardInterface;

class BoardingCardsCollection extends CollectionBase
{

    public function add($element): CollectionInterface
    {
        if ( !($element instanceof CardInterface) ) {
            throw new \Exception(sprintf("Expecting CardInterface got %s", gettype($element)));
        }
        return parent::add($element);
    }

    public function remove($element): CollectionInterface
    {
        if ( !($element instanceof CardInterface) ) {
            throw new \Exception(sprintf("Expecting CardInterface got %s", gettype($element)));
        }
        return parent::remove($element); // TODO: Change the autogenerated stub
    }

    public function sorted(): CollectionInterface
    {
        // Boarding cards hash table (for O(1) search)
        $hashes = [];

        // Departures and arrivals counters
        $departures = [];
        $arrivals = [];

        // Calculating hashtable for cards
        // Spending n iterations
        foreach ( $this as $card ) {
            // Useless for algorythm, but useful for IDE suggestions
            if ( !($card instanceof CardInterface) ) {
                continue;
            }
            $arrivalHashCode = $card->getArrival()->getHashCode();
            $departureHashCode = $card->getDeparture()->getHashCode();

            if ( !isset($hashes[$departureHashCode]) ) {
                $hashes[$departureHashCode] = $card;
            }

            $arrivals[$arrivalHashCode] = isset($arrivals[$arrivalHashCode]) ? $arrivals[$arrivalHashCode] - 1 : -1;
            $departures[$departureHashCode] = isset($departures[$departureHashCode]) ? $departures[$departureHashCode] + 1 : 1;
        }

        // Get initial departure point(s)
        $initialDeparturePoints = array_filter(array_diff_key($departures, $arrivals), function ($value) {
            return $value > 0;
        });

        // Departure points quantity validation
        $departurePointsCnt = count($initialDeparturePoints);
        if ( $departurePointsCnt !== 1 ) {
            throw new \Exception(sprintf("Expecting 1 initial departure point got %d", $departurePointsCnt));
        }

        // Structure consistency validation (we need at least 1 valid decision)
        // TODO: invent some smart method for fast merge&sum by keys

        // Beginning to iterate with initial departure point
        $resultingCollection = new BoardingCardsCollection();

        // TODO: current implementation doesn't work correctly with repeatable cards (NZK -> MSK -> SPB -> MSK -> JPN)
        // We don't want to break anything inside current collection by removing elements.

        $currentDeparturePointHash = key($initialDeparturePoints);
        $currentDeparturePoint = $hashes[$currentDeparturePointHash]; // Since we have only 1 element it's valid
        unset($hashes[$currentDeparturePointHash]);
        $resultingCollection->add($currentDeparturePoint); // Adding first departure to resulting collection

        while ( !empty($hashes) && ( $currentDeparturePoint instanceof CardInterface) ) {
            $arrivalHash = $currentDeparturePoint->getArrival()->getHashCode();
            if ( isset($hashes[$arrivalHash]) ) {
                $currentDeparturePointHash = $arrivalHash;
                $currentDeparturePoint = $hashes[$currentDeparturePointHash];
                unset($hashes[$currentDeparturePointHash]);
                $resultingCollection->add($currentDeparturePoint);
            } else {
                $currentDeparturePoint = null;
            }
        }

        return $resultingCollection;
    }
}